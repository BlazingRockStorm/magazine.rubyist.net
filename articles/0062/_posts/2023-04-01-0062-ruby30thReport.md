---
layout: post
title: プログラミング言語Ruby30周年記念イベント レポート
short_title: プログラミング言語Ruby30周年記念イベント レポート
tags: 0062 Ruby30thReport
post_author: neko314
created_on: 2023-04-01
---
{% include base.html %}

## プログラミング言語Ruby30周年記念イベント

2023年２月25日、Ruby誕生30年を記念したイベントがに開催されました。
2020年から流行した新型コロナウィルス感染症の影響で、一時期のインベントは全てオンラインでの開催が主流となっていました。
本イベントも当初はオンライン形式で予定されていましたが、当日はオープンソースラボをメイン会場として開催されました。

![集合写真.png]({{base}}{{site.baseurl}}/images/0062-Ruby30thReport/集合写真.jpg)

開催日
: 2023-02-25 (土) 13:40 - 17:30

開催場所
: 松江オープンソースラボ

主催
: 一般財団法人 Rubyアソシエーション / 一般社団法人 日本Rubyの会

公式ページ
: [プログラミング言語Ruby30周年記念イベント](https://30.ruby.or.jp/)

進行
：前田修吾

公式ハッシュタグ
: #ruby30th

動画
: [アーカイブ動画](https://www.youtube.com/watch?v=cmd5NdMjHkI)

![松江会場.jpg]({{base}}{{site.baseurl}}/images/0062-Ruby30thReport/松江会場.jpg)

## オープニング

スピーカー
: 角谷信太郎（一般社団法人日本Rubyの会 理事）

スライド
: <https://speakerdeck.com/kakutani/ruby30th-opening>

Ruby30周年のイベントにあたって、まず、アンチハラスメントポリシーがあります。コミュニティーに関わるそれぞれの人が一人の人間として属性やバックグラウンドによらず排除されることなしに、安全で敬意を伴った実りあるコラボレーションとしての場というのは一人一人が頑張って維持していかないといけないものですので、ご協力よろしくお願いします。

この場を借りまして、昨年の12月に亡くなられたChris Seatonさんのご冥福をお祈り申し上げます。Chrisさんは技術的にはもちろん、コミュニティーの皆さんへのリスペクトをすごく大切にしている方で、このような大事なRubyistをなくしたのは残念な気持ちです。Chrisさんと個人的な交流はなかったのですが、RubyConfとかでTruffle Rubyの自慢を朗々とやった後にチームのみんなをメンションしてたのがよかったし、RubyKaigi 2021年ではキーノートをやっていただいて、Object Shapesの考え方をすごく丁寧に解説してくれてて、これからどうなっていくんだろうなという気持ちでいたので、すごく残念です。皆さん、今いる人たちと仲良く交流してやっていきましょう。

オープニングを始めます。Ruby30周年おめでとうございます。申し遅れましたが角谷と申します。Rubyist-istを名乗っております。これはRubyistが好きという意味です。一般社団法人 日本Rubyの会の理事をやっています。他には昔勤めていた永和システムマネジメントの顧問をやったり、まつもとさんも評判いいらしいよと言ってくれているフィヨルドブートキャンプというスクールの顧問をやったり、RubyKaigiではSeñor Organizerという肩書きでやっております。今年のRubyKaigiは5月に、「松本にまつもとさんを行かせる」という松田さんの壮大な冗談で、松本で開催します。皆さん来てください。今年RubyKaigiがリブートして10年になります。ここまで松田さんとそらはさんが繋いで育ててくれて、ありがとうございます。
松本はまちが綺麗だし、まちの中に水が無料で湧いてるんですよ。そばも美味しいのでぜひ来てください。今年も絶対楽しいと思います。

個人のプロジェクトで、Rubyの入門書の先っていうのでJeremy Evansが書き下ろした本を翻訳しています。ぜひ買ってください。

30年前、1993年、皆さん何していましたか。ジュラシックパークが30年前なんですよ。当時僕は学割でジュラシックパークを見ていましたが、彼女の方が僕よりUnix詳しかったです。今見たら「どうなってるのこれ」となりますが、一方Rubyは30年経っても迷走せずに安定していてすごいなと思います。あとは「男はつらいよ」が、バブルが弾けてみつおが就職しづらい回で、Rubyの誕生とも関係する、世相を反映した年でした。

みなさんはRubyのどこからやってきましたか。僕は確か20世紀の終わり頃でした。当時通勤経路に池袋のジュンク堂があって、毎日通ってたんですよ。6階に毎日のように行ってて、
大体2000年ごろに『オブジェクト指向プログラミング言語Ruby』『XP エクストリームプログラミング入門』『達人プログラマ』にまとめて出会ったんですよね。98年くらいに就職してたんですけど、コンピュータとかプログラミングはいいなと思っていたのに、仕事があまり楽しくなかった。なんなんだこれ、と思っていて自分がおかしいのか世の中がおかしいのかわからなかったんですが、この3冊に出会って、世の中がおかしいと確信を持って…ということは自分がおかしくなったのかもしれないですね(笑)そこから今に至る旅が始まります。ケントベックは「プログラマもちゃんとした人間になれる」「今までいた世界がおかしかったのかもしれないよ」と言ってくれている。その結果Rubyコミュニティーの一員として、Rubyを使っているチームがアジャイルになっていく手伝いをしていて、内なる平和を得ました。

今日、2023年。気づいたら僕はずっと同じ話をしているんですね。「ワールズ・エンド」という映画があって、主人公は高校の時の思い出を23年引きずっている無職の人で、まちを出た同級生に会いに行ったらみんなすごく偉くなっている、という話です。今日の皆さんの話を聞いていると、周りはすごくなっているのに自分はずっと同じじゃんみたいな気持ちにながら、今日のオープニングの話をしていました。

今日一日楽しんでください！

## 特別講演: Rubyの30年

スピーカー
: 高橋征義（一般社団法人日本Rubyの会 代表理事）

高橋さんがRubyの歴史をまとめた「年表」(<https://github.com/takahashim/ruby-history>)

### Rubyの30年

30周年おめでとうございます。

30年を振り返ると、過去25年で、Rubyが広く普及してきました。ちょうど真ん中の 2008 年にRuby1.9がリリースされたり、MerbがRailsに取り入れられたりしました。
直近5年では、今後の飛躍に向けた改善がなされていると言えます。

### もうちょっと詳しく

1993 年 ruby が誕生しました。しばらくの間はユーザーはまつもとさん自身でした。

1995 年 ruby が初めてネットニュースに載りました。

1997 年 プロクラミング言語に関心のある層にリーチしていきました。初めてインターネットメディアに（Internet Watch）に取り上げられました。<https://internet.watch.impress.co.jp/www/article/970922/ruby.htm>。[TRY!PC 11月号に「ちょーわかりやすい！Perl & ruby 入門」](https://blade.ruby-lang.org/ruby-list/5050)。この時、「Perl」と並べた時のバランスを取るために「Ruby」と大文字始まりの表記にすることになったと言われています。[オンラインソフトウェア大賞97](https://www.nmda.or.jp/enc/fsp/sjis/osp97.html)に Ruby が入賞しました。

1999 年 [ruby-lang.org 取得](https://blade.ruby-lang.org/ruby-list/17000)。世界初のRubyの書籍・[『オブジェクト指向スクリプト言語Ruby』](https://www.amazon.co.jp/dp/4756132545)が刊行されるなど、Rubyがより広く知られていきました。

2000 年 Ruby に関する洋書["Programming Ruby"(Dave Thomas and Andy Hunt)](https://www.amazon.com/dp/0201710897)が刊行されました。
2001 年には 1 回目の RubyConf が開催され、Ruby が世界にも知られていきました。

Ruby on Rails が登場し Ruby のエコシステムに大きな変化をもたらします。

2003 年に RubyForge.org が公開されました。その頃の様子は [シリーズ パッケージマネジメント 【第 1 回】 RubyGems (1)]({{base}}{% post_url articles/0006/_posts/2005-05-09-0006-PackageManagement %}) で垣間見ることができます）。Ruby標準のパッケージマネージャーがない中 Rails が RubyGems を採用していたことで、最終的には RubyGems が公式パッケージな位置付けとなりました。GitHub が Gem 専用のホストをしていましたが、2009 年に Gemcutter に移行します。 Gemcutter は 2010年3月に RubyGems にリネームされます。 2010 年 9月には Bundlerもリリースされ、 RubyGems と Bundler でパッケージ管理が行われるようになりました。

その頃Merb が取り込まれたバージョンであるRails 3.0 が公開されました。Rails は多くのライブラリを巻き込んで動かすため、パッケージ管理に与えた影響が大きかったのだろうと思います。Rails の開発とともに Ruby のエコシステムも構築されていきました。

### 30周年に寄せて

そんな感じで 30 年が経ちました。感想を一言で言うと「生き残っていて嬉しい」です。30年も経つと、動かすだけでも大変だったり、メンテされていたとしても新しいものはリリースせず既存で動くものが動くようにメンテナンスするものもある中で、30年経っても動いているだけで嬉しいわけです。しかもだんだんより良くなっています。それは、処理系実装者の皆さんの尽力の賜物ですし、ライブラリ開発者の皆さん、ドキュメント・情報提供などコード以外の活動をしている皆さん、Rubyを採用している企業、Rubyのプロダクトや開発者を支えているみなさんのおかげです。30 年間、Ruby は多くの人に支えられて成長してきたし、多くの人を支えてきました。

今日は30年の節目の記念すべき一日という位置付けではありますが、30年はこれまで続いた歴史・発展の通過点とも言えます。Rubyの今後が楽しみです。

## 招待講演1: Enterprise Platform SaaSにおけるRubyの12年

スピーカー
: なひ（Treasure Data CTO）

### 自己紹介、会社紹介

30周年おめでとうございます。
Ruby歴は24年くらいで、私がRubyを触り始めたのは1999年でした。その頃仕事ではPerlを使っていました。使い始めた時のRubyのバージョンは1.2.6で、しばらくはRubyユーザーだったが、2003年くらいにRuby1.8で標準ライブラリを大幅に追加しようという話があって、そのいくつかを提供する中で標準ライブラリのメンテナー、RubyのコミッターとしてRuby1.9、2.0の頃まで活動していました。途中からJRubyのOpenSSLを全部作り直して動くようにするということをやっていました。
2014年にTreasure Dataに入社し、現在はCTOをやっています。そこから先はRubyユーザーとしてRubyを使っています。

Treasure Dataは2011年にシリコンバレーで創業した、現在はCDP（Customer Data Platform）というEnterprise Saasをやっている会社です。Dataを使ってIntelligent
なFoundationを作ってHuman Lifeにコントリビュートしようというビジョンを掲げるなかで、今はCDPをやっています。エンジニアの中にRubyコミッターが4人います(@nalsh, @spikeolaf, @k_tsj, @mineroaoki)。少し前まで @k0kubun もいました。
今日はTreasure Dataが創業してから12年、どのようにRubyを使ってきたかという話をします。

### Treasure Dataの現在のシステム構成

Rubyを使っているところ以外は、UIはJavaScriptで、クライアントSDKは色々な言語を使っています。クラウド上（すべてAWS）では、AWSのサービス、JavaやJVMで動いているもの多いです。それでもRubyを使っている部分は多い方なんじゃないかと思います。

規模としては、サービスチームが20、システムコンポーネントが30、リージョンは5つ。デプロイしているものでは、クラスターが550こ。ECSインスタンスは3200〜3500、さらにLamdba や Flinkアプリケーション、podsなどいいろあります。

プロファイル(CDPのお客さんが集めた個人情報)がシステム上には合計700億件。そのプロファイルをマーケティングなどに活用するのが月に1000億件100B。取り込んでいるイベントが月に3兆件3000B。処理しているレコードは月に6000トリオンです。システムは全てマルチテナントで作っています。

### 2011 年〜 Hadoop as a Service

2011年当初は、Hadoop as a Serviceでやっていました。Ruby30周年のパンフにも載っているfluentdをクライアントSDKとして提供して、ユーザーにインストールしてもらい、色々な情報のソースをプラグイン実装で組み合わせてTreasure Dataのクラウドにログを送信できるようにしました。同様に、HadoopをAPI経由で実行して収集したログを解析できるCLIを提供しました。どちらもgemとして配布しました。
クラウド側は、Railsアプリが1つドーンとあって、APIとUIがそこに実装されていました。Hadoopのプロセスの実行、プライオリティ制御やリトライ制御などの分散ジョブキューをMySQLとRubyで実装していて、今でも走っています。それを元に、HiveジョブのJVMプロセスをfork & execで動かすと。分散ジョブがある点がちょっと違うかもしれませんが、スタートアップがRuby On RailsでSaaSを作りますというとこんな感じになる、標準的な構成かなと思います。

### 2013 年〜 Big Data Platform

2013年からはBig Data Platformとしてやっていました。この頃、JavaScript SDKを作って、それまでfluentdでログを収集して分析してという形だったものをブラウザから直接イベントを収集できるようにしました。サーバーにfluentdを置いて、HTTPのインプットプラグインとしてNginxの裏で受けて、イベントをバッファリングして、コンパクションして、アグリゲーションした結果をストレージに格納するという仕組みで、それをRubyで実装しました。具体的にどのようにやっているかは、スライドのリンク集に書いてあります。

その頃、fluentdがマイクロバッチでデータをストリーミング転送するものなのに対して、バッチでトランザクショナルにリライアブルに転送するためにEmbulkというのをOSSで開発しました。色々な種類のソースをプラグインで組み合わせて使う点はfluentdと一緒です。EmbulkはJavaで実装しました。しかし「プラグインをRubyでも使うようにするのはどうだろう」ということでJRubyを使ったところ、色々なプラグインがRubyで出てきて、Embulkも広まっていきました。
Treasue Dataとしてはそれをクライアント側にもサーバー側にもおいて使っていました。

### 2015 年〜 DMP：Data Management Platform

2015年頃からはData Management Platformとして機能を拡張していきました。その時増えたのがDigdagです。この頃はTreasure Dataの中でも「ハイパフォーマンスなものはJavaで書くよね」というのがあって、DigdagはRubyでは書かれていません。Embulkも最初はJavaで書いていて、Embulkを作って、Digdagを作って、データマネジメントのパイプライン管理をしていました。その頃同時に、JSで作っていたUI部分をRailsから分離しました。流れとしては正しかったと思いますが、要因の一部として、北米で採用してRailsでUI開発するのは辛くて、グローバルチームでUXxUI開発ができるようにしたかった点があります。他にはRails Adminで管理コンソールを追加しました。これはどこでもやっていることかなと思います。

他には、これはこの時期てはなくて当初からやっていたことなんですが、Treasure Dataの全ノード、全コンテナにfluentdが乗っていて、Nginxのログとか、Railsのログとか、アプリケーションのログを全てTreasure Dataに送るというドッグフーディングのようなことをしていました。集めたログをメトリクスや障害の調査、分析のサポート、プロダクト向けのデータ分析に使っていました。それだけではなくて、アグリゲーションしたシステムメトリクスをメトリクスサーバーに送ることもしています。

### 2017 年〜 CDP：Customer Data Platform

2017 年にCDPにピボットしました。CDPが何かというのはリンク先の、青木峰郎さんが書いてくれた資料を読むとよくわかるので、興味がある人は見てください。Treasure Dataのユーザーが作っているデータのワークフローやデータパイプラインを見ていると、どうやら、Treasure Dataのお客さんのお客さんのデータを集めて分析してマーケティングに活用するサービスを各自で作っているということがわかりました。だったらTreasure Data上でそういうサービスを作りましょうということで、RailsでCDP APIをガーっと作り、ピボットしたと。

その頃、認証とアクセスコントロールのAPIをRails製のデータプラットフォームからRailsのまま分離しました。なぜやったというと、この2つと他のAPIの負荷トレンドが異なるのと、これらが落ちると他が全部止まるので、切り出すことでオートスケーリングを容易にするためです。「ある処理は時間がかかる」「ある処理はメモリを食う」というように負荷が均質ではないとオートスケーリングは難しいが、「認証だけ」とか「アクセスコントロール」のように切り出せば負荷が平準になるのでオートスケーリングが容易になる、ということで切り出しました。

### 2019 年〜 CDP：Customer + IoT

2019 年Treasure DataがArm社に買収されてArmと一緒にIoTもやろうということでCDPに加えてIoTをやっていました。そこで、これまでRubyで作って運用していたものからストリームインポートの大部分とジョブコントロールの一部を少しずつ切り出してKotlinで再実装していくことになりました。ジョブコントロールについては今も、Kotlin以外のJVMのものも含め、少しずつ再実装が進んでいます。IoT向けの投資があったことだけでなく、これまでより1桁2桁多いデータ量を扱うことになったのでスケーラビリティとリライアビリティの観点からJVMを選んで再実装していったという流れになります。

その中でも、オペレーショナルなデータアクセス用のAPI新しいビジネスロジックはRailsアプリとして追加していきました。

また、これもあまり楽しくない話をしなければならないのですが、CDPで集めたデータを、ユーザーがクラウド上で分析したりマネジメントしたりするための実行環境を提供していてPythonのみをサポートしています。Rubyで提供できないわけではないのだけど、データサイエンスやマシーンランニングをやる人はみんなPythonを使うので、それを反映している形です。

### 2021 年〜 Customer Data Cloud

2年前の2021年から、CDPで集めたデータを他のエンタープライズシステムと連携してお客さんがもっと便利に使えるようにしようということをやっています。そのために追加する新しいアプリケーションのビジネスロジックはRailsを使っています。ビジュアライゼーションとか、リソースプロビジョニングなどです。

あとはTreasure Dataがマシーンランニングように使うエンジンを作って、それをユーザーが使えるようにする機能を現在開発中です。これはやはりPythonを使っています。ユーザーがコードを書くわけではないのでPythonでなくても良いのだが、マシンラーニングのエコシステムやグローバルな開発者確保を考えると、Pythonになってしまう。

### まとめ

Treasure DataはRubyとともに12年やってきました。ビジネスロジックの実装は今でも新しく作るものはほぼ全てRailsです。これはRubyの開発者の皆さん、ドキュメントも含めライブラリの開発者の皆さんが作っているエコシステムに完全に乗っかっている形。ビジネス要件は当然変わる、というか増えていく。それに追従して実装を変更していくことを考えると、RubyやRailsの開発者にフォーカスしている強さ、立ち上がりの速さや開発者もコードも柔軟性が高い点からは離れ難いなというのが我々の考えです。2015年か2017年かに、日本以外でRails開発者の確保に苦労した時期はあります。今は北米でもヨーロッパでも苦労することはないので、困らなくなったかなというのはあります。ただ、日本にいると「Railsができる。かつ、分散データシステムに強い」エンジニアがそれなりにいるので、そこら辺が違う。分散データシステムもわかる人がビジネスロジックをかけるのは強くて、ある程度日本のエンジニアに頼っているところはあります。

マイクロサービス化したAPIはJVMになりがち。マルチテナントで、いつ需要があるかわからないので、オートスケーリングがよくチューニングされていることが重要。そのためには負荷が均質であることが必要。均質な部分を切り出そうとするとRubyの柔軟さより、肩があるJVMの効率性が重要になってる。認証やアクセスコントロールなどの柔軟性が重要なものは引き続きRailsでクライアント側のキャッシュを使うことで問題を回避しています。

データサイエンスやデータマネジメントでは開発者確保の理由からPythonを採用している。これが開発体験を重視するような流れになったらRubyにできるかもしれません。

最後になりましたがもう一度。
Ruby30周年おめでとうございます。
Rubyコミッターの皆さん、コミュニティーの皆さん、いつも継続的な開発をありがとうございます。それでは発表を終わります。

## ライトニング・トーク

オンライン形式でしたが、一人5分、コロナ禍で数年間機会が減ってしまっていた懐かしのLT形式でした。
タイマーは、時間が来たら銅鑼がなる、修吾さん作Ruby Wasm製アプリでした。

![LT.jpg]({{base}}{{site.baseurl}}/images/0062-Ruby30thReport/LT.jpg)

### rubyとブロックチェーン（仮）

スピーカー
: 素数

Pythonで数理シミュレーションをしている素数さんが、Rubyで素数判定を使った暗号理論の発表をされました。

### Ruby Everywhere 全てがRubyで書ける世界へ

スピーカー
: Hir0_IC

ポータブルなRubyであるmrubyによって”Ruby Everywhere(どこでもRuby)”が実現している話と、これまでの30年、mruby、mruby・cがそうであったようにこれからもRubyとともに進化していくだろうという発表でした。

### RuboCopメンテナーしぐさ 2023

スピーカー
: 伊藤浩一

スライド
: <https://speakerdeck.com/koic/rubocop-philosophy>

 誕生当初代統一フォーマッターを目指していたRuboCopは、今ではコミュニティー内のさまざまな好みや事情を反映し、Ruby Style Guideをデフォルトとしつつカスタマイズできるようになっています。RuboCopメンテナーとして多くのユーザーにとっての利便性を一番に考えて活動している話や、理想のRuboCopはどのようなものだろうかという内容でした。

### 初刷り 何冊買いました?

スピーカー
: Masatoshi Seki

「初刷り買えます」とは、ご自身の著書である『dRubyによる分散・Webプログラミング』をアピールする、RubyKaigiミーム。RubyKaigi 2006での「初版買えます」からRubyKaigi 2022に至るまでの登壇とともに「初刷り 何冊買いました?」に至るでの歴史。かさばらないので電子版『dRubyによる分散・Webプログラミング』を買おう。

### Ruby (MRI) の好きなところ30

スピーカー
: 塩井美咲 (しおい)

タイトル通り、しおいさんの、Rubyの好きなところを5分で30個（!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!）発表する内容でした。

### Pythonのこの機能がRubyに欲しい

スピーカー
: うなすけ

スライド
: <https://slide.rabbit-shocker.org/authors/unasuke/ruby30th-lt/>

Rubyアソシエーション開発醸成金2022に採択された、Python実装の[aioquic](<https://github.com/aiortc/aioquic>)をRubyに移植する取り組みの中で、Pythonにあっていいなと思った機能、逆にRubyにあって良いなと思った機能についての紹介でした。

### Red Data Tools で切り開く Ruby の未来

スピーカー
: mrkn

スライド
: <https://speakerdeck.com/mrkn/red-data-tools-deqie-rikai-ku-ruby-nowei-lai>

Ruby用データ処理ツールを開発するプロジェクト・[Red Data Tools](<https://red-data-tools.github.io/ja/>)の活動概要と、Ruby用データフレームワーク、[Red Amber](<https://github.com/heronshoes/red_amber>)、　[Polars Ruby](<https://github.com/ankane/polars-ruby>)、 [Daru](<https://github.com/SciRuby/daru>)、 [pandas](<https://github.com/mrkn/pandas.rb>)の紹介でした。興味がある方はRed Data Toolsで一緒に開発しましょう！

### たのしいString

スピーカー
: ima1zumi

スライド
: <https://speakerdeck.com/ima1zumi/tanosiistring>

Encoding入門話に始まり、GitHubのSlack用アプリで実際にあった文字化け不具合を再現してみたり、`Encoding#replicate`でエンコーディングを追加してみたり、`Encoding#replicate`はima1zumiご自身のgemである[RubyEncodingIroha](https://github.com/ima1zumi/ruby_encoding_iroha)でしか使われていなくてRuby3.3では無くなってしまうという完璧なオチまでついた、Encodingがよくわかるお話でした。

### Rubyでメシを食う

スピーカー
: こしば

以前はRubyで同仕事をしていくかということを話していたが、2000年代〜2010年代やっていたRubyコミュニティーでの活動が縁となって仕事に繋がっているなと感じておられることや、パートナーである小芝美由紀さんは[『現場で使える Ruby on Rails 5速習実践ガイド』](<https://book.mynavi.jp/ec/products/detail/id=93905>)の著書の一人で、家族ぐるみでRubyに関わりRubyでメシを食っているなという話でした。

### Rubyでハローワールドする30の方法

スピーカー
: 大倉雅史

スライド
: <https://speakerdeck.com/okuramasafumi/30-ways-for-hello-world-in-ruby>

タイトル通り、Hello WorldをRubyで出力する方法30個のご紹介でした!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### Ruby 30年の歴史に思いを馳せる

スピーカー
: mame

Ruby全バージョン（0.49〜3.21の215個）で動くQuineを作った話。バージョン間の構文違いなど差分はあれどちょっと（⁉︎）なんとかすると完成したそうです。
詳しくはこちらに<https://github.com/mame/all-ruby-quine>

## 招待講演2: Ruby 1.9から見る風景

スピーカー
: 園田裕貴(Yugui)（Niantic / Senior Software Engineer）

### はじめに

Ruby30周年おめでとうございます。
Yuguiと言います。Ruby1.9.1 / 1.9.2 のリリースマネージャーをしていました。
仕事ではRubyを使っておらず、Rubyの開発にも携わっていないので、今日は当時の昔話をするつもりです。最後に少しだけ最近の話題も盛り込めたらと思ています。

### Ruby1.9の頃

高橋さんの話でもあったように、Ruby1.８から1.9というのは、文法的に、ライブラリ的に、エコシステムとして、すべてが変わっていった大変更の時代でした。また1.8の頃からRailsが圧倒的な存在感を放っていて、それがますます増していった時代でもありました。

Ruby1.9で入った変更というのは具体的には、言語本体の評価に関する仕様変更（YARV / Native Thread）, 組み込みライブラリの変更（文字列エンコーディング）、添付ライブラリの変更（RubyGems / 鬼車 / Ripper）, 課題管理システムの導入（bugs.ruby-lang.org）、どういったプラットフォームをどういう優先付で開発するかというサポートレベルの設定などです。

実際、年表にまとめてみると、Ruby1.9.1以前というのは、Railsの登場、RubyKaigiの始まり、Railsが業界スタンダードになっていった時代というのがわかります。

変更にはもちろん理由があります。1つは、Rubyを使いやすくするにはどうした良いか、Rubyの中をよくするにはどうしたら良いかという技術的な課題。もう1つはRubyを開発する仕組み上の問題を解決するにはどうしたら良いかという運営上の課題。これらを解決するために大変更が行われました。

### Ruby1.8の頃の技術的な課題と解決策

当時の技術的な課題は大体『Rubyソースコード完全解説』に書いてあります。それ以外にはGC、評価器の速度、ユーザースレッド、多言語化、パーサの再利用、正規表現エンジン、ライブラリ配布といった課題がありました。これらに対しRuby1.9以降、世代別GC・Copy GC、YARV、Native Thread、Encoding、Ripper、Oniguma / Onigumo、RubyGems / Bundlerといったもので解決がなされていきました。そのうち1.9時点でYARV、Native Thread、Encoding、Ripper、
Oniguma、RubyGemsが導入されました。

まず、評価器の速度について。Ruby1.8までは、ASTのNodeを再帰的に評価する仕組みでした。しかしRubyが広く使われるようになりユースケースが広がると、そのやり方だと遅いと問題になっていきました。そこでYARVが導入され、ASTを仮想マシンコードにコンパイルしてから実行する仕組みに変わりました。

次に、ユーザースレッドについて。それまでのRubyにもマルチスレッドの仕組みはあったがOSから見るとあくまで1つのスレッドで、その中でコンテキストを切り替えることで擬似的にマルチスレッドを実現するものでした。OSから見ると1つのスレッドでしかないのでマルチコアで実行することができません。そのためマルチコアを活用するにはマルチプロセスにするしかない。しかしプロセスを増やすとリソースを消費するし管理も大変になるという問題があります。RubyのスレッドをOSのスレッドを1:1でマップすればマルチコアの利点を活用できる。という大変更が入りました。

多言語化について。当時のRubyのエンコーディングで重要なのはKCODEで、KCODEにエンコーディングの名前を代入すると全ての文字列オブジェクトの挙動が変わるという仕組みでした。個々の文字列オブジェクト自身はエンコーディングを持っておらず、ただのバイト文字列だったと言えます。文字リテラルも、対応するバイトを返していました。これだと、1つのプログラムの中で異なるエンコーディングのデータを扱うのが大変です。またKCODEが日本語に特化したものだったので、それ以外の言語への対応も大変でした。それに対し、Stringオブジェクトがエンコーディングを持つように変更が入りました。その結果、エンコーディングが間違っていればエラーを吐く、文字列オブジェクトがエンコーディングを持つので文字単位のイテレートが可能に、`external_encoding`・`internal_encoding`でRubyプロセスの外からエンコーディング情報をとってきたり適切に変換がされるように、また文字リテラルが数字ではなくその文字を表すオブジェクトを返すようになりました。

Ripperや鬼車について。irbのように、Rubyプログラムの中でRubyコードを処理したいことがあります。Rubyコードをパースして処理する必要があるのですが、Rubyコードをパースするのは恐ろしく複雑です。Rubyの文法の柔軟性はパースの大変さでもあります。それまではRubyをパースするには自分でなんとかする必要がありました。ここでRuby本体のparse.yとパーサーを共用したRipperが導入されRubyコードを処理するRubyコードを書きやすくなりました。さらにRuby1.８までの正規表現ライブラリではエンコーディング周りがややこしかったり、現在と比較して機能が限られていたという問題やライセンス周りの問題がありました。そこに鬼車が登場し、すごく強力な正規表現ライブラリを使えるようになりました。

重要なトピックとして、ライブラリ配布の話題があります。昔のRubyではライブラリをインストールするのはすごく大変なことでした。推移的な依存関係を人手で把握して正しいところからダウンロードする、アーカイブを展開する、正しいロード可能なディレクトリに配置する、あるいは環境変数を設定する必要がありました。親切なライブラリであればそれらを自動化するインストーラーがあったかもしれませんが、それだとライブラリ作者がちょっと大変ですね。さらにいうとライブラリ同士、最新版同士で互換性があるわけではないので、全ての条件を満たすバージョンを特定してダウンロード、インストールしなければいけませんでした。これは本当に大変でした。ちょうど、依存関係を自動解決して適切にインストールできるRubyGemsが登場して、Ruby1.9から本体に添付されるようになりました。

### Ruby1.8の頃の運営上の課題と解決策

運営上の課題で言うと、当時まつもとさんに負荷がかかりすぎていました。つまり、言語の変更をしたいと言われたらジャッジし、Rubyの将来について考え、人と会って話し、さらにパッチを取りまとめて安定してリリースできるバージョンにする。その間にも色々な人がRubyに変更を加えるので、うまいこと管理し、リリースできるものを作り上げないといけない。明らかに一人がやるには大変すぎていました。そこでリリースマネージャーの仕事を分離していきました。Ruby1.8では卜部さんがリリースマネージャーをしてくれていたので、1.9.1 / 1.9.2では私が手を挙げて担当しました。

課題管理という問題もありました。それまで、バグ報告・トラッキング、仕様変更の議論・提案はすべてメーリングリストで行われていました。メーリングリストだと、メールスレッドが流れるといつの間にか忘れられてしまうという問題があります。この問題を解く方法は現代であればみなさんご存知だと思います。Issueトラッカーを入れるといい。そこでいくつか検討した結果Redmineを採用し、今でいうbugs.ruby-lang.orgを立てました。1つ自慢したいのは、いきなり完全移行するのは無理なので、メーリングリストに報告されたものはRedmineに、Redmineに報告されたものはメーリングリストにも流れるような拡張を書いて適用しました。

それからRubyはさまざまなプラットフォームをサポートしていますが、それら全部を等しくサポートするのは大変なので、優先度付けをして、とにかくメジャーなプラットフォームだけはしっかりしたものを出す体制を作りました。

その結果1.9.1から2.xごろまでで、リリースマネージャー制の確立、Issue Trackerもある、CIもある、GitHubにリポジトリもある、VMで実行する、Native Treadがある、GCに凄いアルゴリズムが導入された、多言語対応ができた。今では当たり前と思うような開発体制、言語機能が確立していました。

### 残された課題・新たな課題

それでも残っている課題や、新しく出てきた課題もあります。もっと速くしたい、型による利便性が欲しい、スレッド難しい、いろんなところで動かしたい、誰も信用できない、色々なビルドがある、などです。

もっと速くしたい課題についてはJITが入り、もう運用されつつあります。型による利便性が欲しい課題については、RBSや型チェッカーで、型解析によってIDEの補完を効かせたりスタッティックに検証したりすることができるようになっていっています。スレッド周りは1.9で大きく変わりましたが、そもそもマルチスレッドプログラミングは難しい、RubyのスレッドとOSのスレッドを対応させるとしてもOSのスレッドを大量に作ろうとすると効果すぎる問題がありました。この辺りはRactorで解消されつつあります。その後出てきた問題として、もっといろんなところで動かしたい、例えば「Ruby以外で書かれたプラグインとして実行したい」というニーズは当然あります。これに対してはNative Client対応を入れようとしていました。最近では同じ問題をRuby WASMが解きつつあります。

誰も信用できない、というのは、サプライチェーン攻撃に関することです。このリスクが近年高まりつつあります。であれば、外部パッケージをインストールするときにそのパッケージの素性みたいなものをきちんと分析したい。パッケージ管理操作の、メタデータを取得する、ビルド手順を検証するなど段階で信頼できないコードが実行されてしまっては大問題です。RubyGemsはこの点はすごく優秀で、仕組み上他の言語ではどうしても信頼できないコードが走ってしまうことがある。RubyGemsではこのような問題はありません。スタティックなJSONだからです。1つ弱点があって、拡張ライブラリを使っていると、それを取得する段階で信頼できないコードが走ってしまう。ここだけはなんとかしたらいいなと思っています。解決策としてはいくつかあると考えられます。1つはクロスビルドがもっと簡単だったら、それぞれの拡張ライブラリをあらかじめビルドしておいて、プレビュードバイナリをGemに埋め込んで配布する選択肢がもう少し現実的になるかなと思います。あるいは、この問題はextconf.rbという拡張ライブラリの仕組みに深く根ざしているので、それに代わるもっと良い何かがあってもいいかもしれません。あるいは、最近Rubyは早いので、速度が必要なものをCで書かなければならないわけではないです。なので、拡張ライブラリとかやめてRubyで書けばいいんじゃないでしょうか。
いろいろなビルドという問題もある。今時では、1つのプロジェクトの中に複数の言語が含まれるのは当たり前です。クロスビルドで配布するのもよく見られます。最近台頭した言語ではクロスビルドはすごく簡単だったりします。コンテナイメージをビルドするのも当然に求められることです。コンテナをビルドする上でビルドは決定論的である、つまり同じソースを与えたらビルドはバイト単位で一致する・同じアウトプットが出てくることが期待されます。これに対しても方向性はいくつかあります。やはりRubyで書くのはすごく良いことです。クロスビルドが大変とかビルドは決定論的であるとかというのは大体拡張ライブラリからくるもので、だったらRubyで書けば、すべて問題は解決なのではないでしょうか。とはいえRubyで書けないケースもあるにはあります。これらの問題に強いBazalというビルドシステムがあり、これのRubyサポートがもっと強くなればいいなと思うので、数年前から時折取り組んでいます。

### 最後に

思い返すとRuby1.9はRubyが現代的になった大きなステップでした。その大きな変更は理由もなくやったわけではなく既知の問題に真摯に取り組んだ結果です。残された問題についても、見てきたように、すでに解かれつつあったりいくつかの方向性が考えられたりします。そんな感じで、Rubyは今も適応を続けている言語で良いんじゃないかなと思います。以上で終わります。

## 招待講演3: Rubyで作る最強ゲーミングルータ

スピーカー
: 奥一穂（Fastly Sr. Principal Engineer）

### 発端

冬休みに入った頃、家族から「自宅にマイクラサーバーを動かしたい」と相談がありました。「パソコン余ってるしいいよ」と言って動かしてみると、「ラグがひどくてみんなで遊べない！」「まじか...」となった。
一般的な対策をググってみると、ブロードバンドルータのQoSを、ゲームに使う機器のIPアドレスの通信を優先するように設定しましょうと書いてある。でも、ゲーム機って複数ありませんか。パソコンもあればゲーム機もあるし、ゲームで使うパソコンで何かをアップロードしている間、他のゲーム機でゲームしたらどうなるんでしょう。どっちも優先されますよね。やっぱりうまくいかないんです。もう1つの問題は、うちのブロードバンドルーターは買い替えたところだったんですが、「このISP向けではQoSは使えません」となっているんですね。ISPのIPv4対応方法がMAP-E方式というものだったのですが、これだとQoSが使えなかった。「まじか...」となるわけですね。

自宅マンションのネットワークは、共用部までは光が来ています。共用部にVDSLの集合モデムが置いてあって、そこからは電話線を通じて各家庭までインターネットが来ていると。VDSLの宅内モデムを使ってパソコンにつなぐというかんじですね。<https://flets.com/first/kouji/const_apartment.html>

具体的な帯域は、ファイバーが自宅まで1GBで来ている。マンションの集合モデムから自宅のVDSモデムまでは下り100MB・上り35MB。そのあとはイーサネットでブロードバンドルータに行って、パソコンやスマホまでイーサネットなりWi-Fiなりでいく、という感じになっています。

fast.comでベンチマークを取ってみました。ダウンロードではアンローデットのレイテンシが7ms、ローデットが36msとなっています。ダウンロード測定時に負荷があると36ms、負荷がないと7msということで、負荷がかかると29ms遅延が増えているということがわかります。ではアップロードの場合どうかというと、アンローデットが8ms、ローデッドが168msになるんですね。アップロード中に遅延が160msも増えているということがわかります。

どうしてこんなに遅延が大きいのでしょう。インターネットが遅いから仕方がないのでしょうか。そうじゃないんです。

### 輻輳制御とボトルネック

ここで輻輳制御というインターネットの技術の話をします。輻輳制御とはパケットの送信頻度やタイミングを制御するための技術です。これによって、インターネットの帯域を使い切ったり、公平に共有したりします。アルゴリズムの例としては、ロスベースと言われる、昔からのRenoやCubicといったものが主流です。最近では遅延ベースのBBRというものも出てきているようですが、今日はRenoやCubicを中心には話をします。

左にサーバーと右にPCがあり、パケットが左から右に流れていると考えてください。その間にルーターが2つあります。サーバーから2つ目のルーターまでは割とパイプが太い（パケット2つ分とする）が、2つ目のルーターからPCの間だけが細くなっている（パケット1つ分とする）。サーバーからPCにパケットが届くとPCからサーバーにackが返ります。またパケットが流れていくとackが返ります。これがインターネットの通信です。これを続けていくとサーバーがパケットを1つ多めに投げるタイミングがあります。多めに投げられたパケットは、最後の細くなったパイプを流れていけないので、直前のルーターのキュー、バッファーに溜まります（1つ分溜まっている状態）。通信を続けていくとまたパケットが多めに投げられるタイミングがきます。それがルーターに溜まります（2つ分溜まった状態）。しばらく続けるとまた多めに流れてきて、ルーターに溜まります。これを繰り返してルーターのバッファーがいっぱいになります。それでも通信を続けていくとまた多めに流れてきて、ルーターのバッファーがオーバーフローします。パケットが捨てられるわけですね。ackが順番に返っていて、捨てられたパケットのackが返らないといけないのだがそれは返らず次のパケットのackが返るので、その瞬間にサーバーは「パケロスが発生した」と気づくわけですね。パケロスに気づいたサーバーはしばらくはダンマリを決めて、PCからackが返ってきても次のパケットを投げません。しばらくしてからパケットを投げ始めます。この無通信の間にルーターのバッファーがはけていくので空いたスペースができます。そして通信を続けていくと、またサーバーが余計にパケットを投げてバッファーにたまる。

バッファーにパケットが溜まっていく、溢れてパケロスが発生し、サーバーが黙る。これを繰り返すのが輻輳制御です。

先ほどのfast.comでの結果からバッファの大きさを計算することができます。無通信時は7ms。92Mpbsだったので、7msで54パケットくらい流れていることがわかります。一方でルータのバッファーの深さは29ms分、220パケットあることが計算からわかります。

輻輳制御はボトルネック直前のバッファにパケットが滞留します。遅延というのはバッファの大きさで決まります。

じゃあ、自宅のネットワークのどこにボトルネックがあるかというと、下りは集合モデムから宅内モデムの29ms、上りは宅内モデムから集合モデムの間の160msのバッファがある。アップロードの遅延を減らしたいと考えると、160msのバッファにデータが溜まらないようにしたいわけです。どのようにすれば良いか。その手前に、もっと細いボトルネックを作ってやればいい。そうすると、一番細いところの直前に溜まるので、ブロードバンドルーターの直前に溜まるようになります。このバッファーサイズをうまい具合に調整してやればいいのです。

### バッファサイズを調整する

バッファの設計には3つのポイントがあります。

第一の要素がバッファの深さです。帯域を優先したいか低遅延を優先したいかで考え方が多少変わります。基本的には帯域を使いたい場合は無通信時の遅延と同じだけのサイズのバッファが必要と考えられています。例えば無通信時のRTTが100msだったらバッファも100ms必要です。理由は、パケロスを検知した時に、RenoはRTTの半分の時間黙るからです。つまりバッファに合計200msの遅延があるとしたらパケロスを検知した瞬間に100ms黙る。その間、バッファに溜まっていた100msのパケットを流し続けたいので無通信時のRTTと同じだけのサイズのバッファが必要ということになります。この点Cubicは黙る時間が短くて23msくらい。これが基本的・古典的な考え方です。低遅延を優先する場合、バッファの深さは無通信時のRTTの5%で良いと考えられています。どのくらいの効率化というとRenoの場合は8割の帯域を使えることになります。2割は無通信です。100Mbpsの回線があって80Mbpsしか使えないんだけれども、RTTがグッと減るからからまあいいだろうと。今日主流のCubicで9割使えるのでほぼほぼ問題ないという感じです。

次にバッファの数です。一般的な通信機ではイーサネットごとに1つあります。ブロードバンドルータのQoSだと、"一般"と"優先"の2つ分かれています。さらにインテリジェントなものになるとIPアドレスとポートの組ごとにバッファを作って、順番に投げさせています。一箇所詰まっていても他のところがちょっと投げてきたら先に投げてしまうといったことが通信の組ごとにできるようになっています。

最後に輻輳の通信方法です。「パケットが溜まっちゃってるよ」というのを通知する方法ですが、古典的な方法は、先ほどみていたパケットを落とす方法です。それ以外には最近だと輻輳検知(ECN)のマークをつけることがあります。「そろそろパケットがいっぱいになってきてるよ」とマークをつけてそのまま流してやるんですね。それがackとともに送信者に戻ります。この方法のメリットは、パケットを落とすと送信者が再送するまで情報が届かないわけですが、パケットを落とさないので再送する必要がなく、再送による遅れがない点です。

まとめると、バッファの設計には3つのポイントがあって、古典的なものが多くのブロードバンドが使っているやり方でした。これに対し、AQM(Active Queue Management)というのが、0.05RTTの深さであるとか、IPアドレス・ポート毎にバッファを持ったり、輻輳検知にECNを使ったりする新しい仕組みです。AQMは最近のLinuxで利用することができます。tc、qdisc, codel、cakeなどで検索すると情報を見つけることができます。

| | 古典的|AQM|
|---|---|---|
|バッファの深さ|1RTT|0.05RTT|
|バッファの数|1(QoSだと2)|IPアドレス+ポート毎|
|輻輳通知|パケロス|ECN|

というわけで、自宅のルーターをLinuxに変えて、AQMを設定したわけです。バンド幅を30MBに絞り、35MBのボトルネックの手前に持ってきました。これでバッファが5MBになりました。
しかしこれだけだと集合モデムから卓内モデムの上りの通信でもパケロスが発生していて、マイクラのゲームが遅延してしまうので、LinuxルーターとPCの間を90MBに絞り、ECNを使ってパケロスを回避することにしました。これでネットとゲームが同時に快適に成しました。

### スプラトゥーンがエラーに

今度はスプラトゥーンがエラーになってみんなで遊べないという問題が起きました。なぜか。Nintendo SwitchはP2P通信を行います。IPv4しか対応していません。そのためマルチプレイゲームはNAT越えをします。Nintendo SwitchのNAT判定は、A・Bは良い、C・Dは悪い、Fは論外みたいな感じです。ブロードバンドルーターの時はBでしたが、Linuxに変えたらDになりました。

NATってそもそも何なのか。家のネットワークがあります。IPアドレスは192.168.0.xです。インターネット通信をやるときに中のIPアドレス(192.168.0.1〜192.168.0.5)には外から直接届かないので、外に届くようなIPアドレス（例えば、x.y.z.a:48923）にルーターで変換してやる。それがNATです。実はNATには2種類あります。1つはCone NATで、外部からx.y.z.a:48923にパケットを送ると、どのパソコン、どのサーバーから送っても同じパソコンに届きますよというものです。もう1つはSymmetric NATで、インターネット上の特定のものからしか届かないというものです。

Symmetric NATにもメリットがあり、ポート枯渇がしにくいんですね。特定の相手としか話さないので、同じポート番号を別の相手に使いまわせるという特性があり、TCPでは一般的に使われます。ただ、UDPの場合、例えばNintendo SwitchでされているようなP2P通信はCone NATが望ましい。使っていたブロードバンドルータはCone寄りの何かだったんですが、 Linux NATに変えた結果Symmetric NATになり、スプラトゥーンを遊ぶのに問題が出てきてしまいました。

Linux NATはMAP-Eとも相性が悪いです。MAP-Eというのは、1つのIPアドレスを何人もで共有するためにポート番号をたくさん刻んで顧客に振ってきます。Linux NATはNATを64個とか立てて、ランダムに選択しながら動かすんですが、それぞれのNATの中でポートが顧客する可能性があり、あまり綺麗なやり方ではないという問題もあります。

### 自作NAT

遅延・パケロス対策にはLinuxが必要だが、Linux NATはゲームには不向き。ではどうすればいいか。NATを自作すればいいんじゃないかという話になるわけですね。

NATの作り方には2種類あります。tuntapと呼ばれるLinuxのAPIを使う方法。もう１つはXDPです。tuntapは、仮想ネットワークのインターフェースで、通常のプログラムでreadやwriteを使ってパケットを読み書きすることができます。主な使用例はVPNです。主要なUnixでサポートされています。XDPは、Linuxカーネル内で、パケット処理をプログラムで書くための仕組みです。非常に制限の多いCで書くのですが、使えるのはLinuxのみです。その代わり100Gbpsとか出ます。

どちらを使うべきか。今回は100Mbps出ればよく、XDPを使う必要がありません。カーネル内のプログラムを書くのは面倒だし、書いたとしても設定や監視ツールもたくさん作らないといけない。ゲームのためにそんなのはやってられない。tuntapをスプリプト言語で叩けば、設定はスクリプトでできるし、監視はHTTPサーバー組み込みでできるかもしれない。tuntapとスプリプト言語でやっつけたい。とはいえ速度は重要です。100Mbpsということは、毎秒1万パケットが流れます。双方向なので、毎秒2万パケット処理しなければならない。そういう、高速でかきやすい言語といえば...Rubyです!!!!

正直、他の言語も考えはしました。TypeScriptとか。でも堅牢なコードを書くために型とか書きたくない。それだったらRustで書く、XDPで書く、という気分になるわけです。そもそも楽をするためにスクリプト言語を選びたい。

というわけで書きました。
<https://github.com/kazuho/rat>

去年(2022年)の12月25日から書き始めて、その日のうちに基本的な部分は動きました。3日間くらいかけて書きました。翌年1月1日にちょっといじって、本番投入しました。先ほどサーバーログインして見てみたら、1月1日に動かしたNATがまだ動き続けていました。2195時間くらいCPUを使っていますが、まだ元気に動いています。Ruby3.2.0で、YJITを使って動かしています。

構成はファイルが5つあって、720行くらい。最新版は機能を足して1028行になっていますが、1月1日時点の720行のものがまだ動き続けています。家のネットワークが止まると面倒食いのでなかなか変えるタイミングがありません。

### 実装

コードを見ていきましょう。パケットを読み書きはこのようになっています。

{% highlight text %}
{% raw %}
// tuneを開く
IFF_TUN = 1
IFF_NO_PI = 0x1000
TUNSETIFF = 0x400454ca
tundev = open("/dev/net/tun", "r+")
ifreq = [devname, IFF_TUN | IFF_NO_PI].pack("a" + Socket::IFNAMSIZ.to_s + "s!")
tundev.ioctl(TUNSETIFF, ifreq)

// 受信
bytes = tundev.readpartial(1500)

// 送信
tundev.syswrite(packet.bytes)

{% endraw %}
{% endhighlight %}

/dev/net/tunというファイルを開いて、ioctlで「このネットワークに繋いでください」と言うと繋がります。あとは、`Socket#readpartial`、`Socket#syswrite`を呼べば、パケットの読み書きができます。

パケットのデコードと変換をどうやるかというと、IPというクラスを作り、`@bytes`に生のバイト列を入れます。`@l3`というプロパティにIPv4ヘッダ、IPv6ヘッダを表現するための仕組みを入れます。IPアドレスの書き換えはチェックサムの書き換えを入れます。同じく`@l4`も作って、TCPのポート番号とかTCPヘッダ、UDPヘッダ、あるいはICMP(Ping等)のポートの読み書きやチェックサムの書き換えをサポートする設計になっています。

NATのコードを見ていきましょう。これがNATのパケットを書き換えるためのコードです。

{% highlight text %}
{% raw %}

class Nat
  def transform(packet)

    // 使用するNATテーブルを決定
    case packet.l4
    when TCP
      table = @tcp_table
    when UDP
      table = @udp_table
    when ICMPEcho
      table = @icmp_echo_table
    when ICMPError
      return handle_icmp_error(packet) unless egress?(packet)
    end
    return if table.nil?
{% endraw %}
{% endhighlight %}

`class Nat`の中に、`transform`というメソッドがあります。これはパケットを受け取とると、まず、しようするNATテーブルをどれにするか決めるために、`packet.l4`を見ます。TCPだったらTCPテーブルを使います。UDPだったらUDPテーブルを使います、という感じです。わかりやすいですね。どのテーブルも使わないんだったらパケットを落とすということでリターンしています。

{% highlight text %}
{% raw %}
　　　// テーブルルックアップして、アドレスとポートを書き換え
    if egress?(packet)
      entry = table.lookup_egress(packet)
      return unless entry

      entry.packets_sent += 1
      entry.bytes_sent += packet.bytes.length
      packet.src_addr = @global_addr
      packet.l4.src_port = entry.global_port
    else
      entry = table.lookup_ingress(packet)
      return unless entry

      entry.packets_received += 1
      entry.bytes_received += packet.bytes.length
      packet.dest_addr = entry.local_addr
      packet.l4.dest_port = entry.local_port
    end

    packet
  end

{% endraw %}
{% endhighlight %}

続いて、このパケットがegress、つまり家の中からインターネットへ向かう場合は外向きのテーブルをルックアップして、何もなければパケットを落とします。テーブルからエントリが返ってきたら、パケットのソースアドレスを自分のグローバルアドレスに、ソースポートをグローバルポートに書き換えて送ります。パケットがingress、つまりインターネットから家の中に入ってくる場合は逆のことをやります。テーブルをルックアップして、アドレスをローカルアドレスに書き換えて、ポートもローカルポートに書き換えてパケットを転送します。

次に、NATテーブルはこんなふうになっています。

{% highlight text %}
{% raw %}

class NATTable
  // NATテーブルのエントリ
  class Entry
    ...
  end

  def initialize(name)
    @name = name
    @locals = {}  // egressルックアップ用テーブル
    @remotes = {} // ingressルックアップ用テーブル
    @anchor = Entry.new
    @anchor.next = @anchor.prev = @anchor // LRU（最終アクセス時順）のリンクリスト
  end
{% endraw %}
{% endhighlight %}

NATテーブルのエントリを表す`class Entry`があります。NATテーブル自体はいくつかのハッシュでできています。まず、外向きのパケットをルックアップするためのテーブルである`@locals`、次に、内向きのパケットをルックアップするためのテーブルである`@remotes`、それから、古い接続はどんどん捨てていかなければいけないので、LRUを管理するためのリンクリストから成っています。これは正直書いていて苦痛でした。遅いから書けないだけで、書こうと思えばSQLで書けるんです。だったら、schemaを書いたらinsertやインデックスを使ったルックアップを自動生成してくれるようなモジュールってないんですかねぇ。そんな気になりました。

無いからとりあえず書くわけですが、実際にパケットの宛先を決めるクラスがどんなふうになっているか。外向きのパケットを決める`lookup_egress`はこのようになっています。

{% highlight text %}
{% raw %}
def lookup_egress(packet)
  entry = @locals[local_key_from_packet(packet)]

  if entry.nil?
    global_port = empty_port(packet.dest_addr, packet.l4.dest_port)
    if global_port.nil?
      // ポート枯渇（省略）
    end
    entry = Entry.new(packet.src_addr, packet.l4.src_port, global_port, packet.dest_addr packet.l4.dest_port)
    @local[local_key_from_packet(packet)] = entry
    @remotes[...] = entry
  else
    entry.unlink
  end
  entry.link(@anchor)
  entry
end
{% endraw %}
{% endhighlight %}

まずパケットに対応するNATエントリを検索します。エントリが見つからず`nil`だったら空いているポートを探してエントリを作って登録します。もし見つかったらそれをそのまま使えば良いです。エントリに関しては一旦アンリンクしてからリンクすることでLRUを更新します。

逆向きの、外からうちに対してのパケットは、テーブルルックアップしてあればそのエントリを使えば良いし、なければパケットを落とせば良いという感じです。

{% highlight text %}
{% raw %}
def lookup_ingress(packet)
  @remotes[local_key_from_packet(packet)]
end
{% endraw %}
{% endhighlight %}

先ほどCone NATとSymmetric NATという2種類のNATがあるという話をしました。この差はクラスの継承で表現しています。NATテーブルから継承しオーバーライドするメソッドが3つあります。外向きのパケットをルックアップするためにCone NATの場合には`packet.src_attr`と`packet.l4.src_port`を使います。送信元だけでポートを決める感じです。Symmetric NATの場合には、送信元・送信先の全部のアドレスとポートを使って決めるようになっています。これが違うので、空のポートを探すための仕組みも違います。Cone NATの場合、空いているグローバルポートを配列で管理し、空いているのが残っていればそれを提供します。Symmetric NATの場合には、相手のアドレスとポートが異なれば同じグローバルポートを再利用することができるので、グローバルポートをランダムで選択し、被っていればやり直す、ランダムでループを回すというアルゴリズムになっています。

次に設定と起動のコードです。使用するグローバルアドレスは、ほぼ固定なので直書きしています。ポート番号も直書きしています。Rubyでループを回して生成して、`table.global_ports`にまとめて突っ込んでいます。

以下がratのメインのコードです。

{% highlight text %}
{% raw %}
Thread.new do
  loop do
    loop do
      packet = tun.read
      next unless packet

      tun.write(packet)
    end
  rescue StandardError => e
    p e.full_message(:highlight => false)
  end
end
{% endraw %}
{% endhighlight %}

スレッドで動かしています。パケットを読んで、パケットが壊れていたりしたら捨てます。次に先ほどの`transform`を呼んで、変換に失敗したら捨てます。成功したら、tunにパケットを書き戻す、というコードです。

Rubyで書いているので、WEBのUIがあります。

{% highlight text %}
{% raw %}
webapp = Proc.new do |env|
  if $webif.nil?
    begin
      $webif = eval(File.open("webif.rb").read).call($nat)
    rescue StandardError, SyntaxError　=> e
      print e.full_message(:highlight => false)
    end
  end
  $webif.call(env)　if $webif
end
Thread.new do
  Rackup::Handler::WEBrick.run(webapp, :Host => '0.0.0.0', :Port => 8080)
end
{% endraw %}
{% endhighlight %}

WEB UIを遅延ロードしてやって、それを実行するためのコードを書いています。別スレッドでWEBRickを使ってこのサーバーを動かしています。UIを遅延ロードしているので、必要に応じてUIのプログラムだけ再ロードして動的に機能を追加できるようになっています。

### ratのバグはirbを使って直す

ratのバグがあったらどう直すかというと、irbを使います。どういうことか。rat自体がirbで動いています。サーバーにログインして、irbでたとえばアイドル時間を100秒にすると、100秒以上アイドル状態だった通信が全部消えました。このように動的に設定を書き換えることができます。Rubyは便利ですね。irbは便利ですね。

Rubyなので、パケットのインスペクション(DPI)も簡単にできます。たとえば正規表現を使ってTLSのSNI拡張というのを拾うコードを書くと、通信相手のホスト名が見えてしまいます。こういったものも簡単に書くことができます。

### まとめ

高機能なNATが実質3日で完成して、これまで見てきたような色々なことができました。ちなみにSwitchのNATタイプは無事にAになりました。Rubyの柔軟性は素晴らしいと思います。その後やったこととしては、速度改善やIPv6対応をしました。ではこれで最強のゲーミングルータはできたのか？ベンチマークをとってみると、全力ダウンロード中にダウンロードの遅延は20ms、しかし別通信のダウノンロードは10ms台でした。非常に速くなっています。低遅延ができています。しかも設定不要です。ECNを使っているので低パケロスにもなりました。NATタイプAになりP2P通信にも対応できました。まとめてみますと、一般のブロードバンドルータにはできないことがあった。LinuxルーターもP2P通信に弱い。LiuxとRubyで全部できる最強のゲーミングルーターを作ることができました。Rubyは素晴らしい。

なぜRubyが素晴らしいか振り返ってみるとRubyは型付けや所有権、テストなどの拘束具がないプログラミング言語ですね。拘束具はきっちりしたコードを書くためには便利だけれど、要らない時もあります。それにRubyは柔軟なプログラミング言語です。eval, require, irb等があるので、設定や周辺ツールを頑張る必要がありません。おかげで問題解決に集中することができます。さらに重要な点として高速なプログラミング言語という点があります。パケットを処理しようとすると高速でないと話になりません。Rubyは速いので、CやC++の処理コードを置き換える時に使えます。NATが動くんだったらルーティングにも使えるんじゃないのかという話も十分あると思います。今強い分野で使われるのもいいですが、新しい分野でもどんどん使われていってほしいなと思います。なんせ速くて楽だから。実際、書いていてすごく楽しかったです。

これをもって「Ruby30周年おめでとうございます」というはなむけの言葉としたいと思います。ありがとうございました。

## 基調講演: D is for Dream, V for Vaporware

スピーカー
: まつもとゆきひろ（一般財団法人Rubyアソシエーション 理事長）

Ruby誕生から30年経ちました。正確には昨日をもって”Ruby”という名前をつけてから30年経ちました。いつも言っていることですたソフトウェアというのは物理的実体がないので、名前をつけた日が（Rubyという）概念が生まれた日だと思っていて、名前によって”Ruby”というものが発生したので、名前をつけた日を誕生日にしようというこたがわりがあります。Wikipediaだと最初にリリースした日が記載されていて、Rubyだと1995年12月21日ということになっていますが、Rubyコミュニティーの中では「名前が重要だ」ということも併せて2月24日をRubyの誕生日としていますし、昨日でそれから30年経ったので30周年ということで皆さんに集まっていただきました。

### なぜRubyが生まれたか

1993年2月にRubyを作った最大の理由は、暇だったからです。当時、バブル経済が崩壊して、私が関わったプロジェクトがキャンセルになりました。今まで作ったソフトウェアをメンテする仕事もいただいたんですが、あまりやることがないんですね。たまに使っている人から電話が来るんですが、そうしたら「立ち上げ直してください」とか、場合によっては「PCの電源入れ直してください」で、以上終わりという感じだったので。マネージャーは、他のお金を稼ぐチームのマネージャーも兼任していたので、こっちを何もみてないわけです。そうすると、ほっとけばプログラミングする人間を、机からデスクトップコンピューターを奪わないで暇を持て余した状態にしておくと何が起きるか、というと、プログラムを書くわけです。そういう感じで不景気のおかげで生まれたのがRubyだったんです。

では、なぜ暇してて作ったソフトウェアが言語だったかという話をしなくてはいけません。
これよりしばらく前なんですが、存在しなかった本として『作りながら学ぶオブジェクト指向』という本が書かれるはずだったんですよ。当時同僚だったら石塚圭樹さんが、最初のRubyの本の共著者になっていただいた方なんですが、アスキー出版でバイトをしていて、アスキーから『オブジェクト指向プログラミング』という本を出した人でもあったので、次の本として先ほどの『作りながら学ぶオブジェクト指向』はどうだろうかという企画があがったんですね。どういう本かというと、オブジェクト指向プログラミング言語を実際に作ってみてオブジェクト指向とは何ぞやを学ぶ本だったんですね。オブジェクト指向を言語処理系を作ることによって学ぶということで、のちに「オブジェクト指向とは何ぞや」というのは無益な論争が起きたわけですけれども、この本が世に出ていたらこのような論争はあまりなかったんじゃないかなと思うような素晴らしい本だったんです。実際にプログラミング言語を作りながら学ぶので、作らないといけないわけですが、当時先ほど行った社内ツールのためにC言語向けのオブジェクトライブラリを作っていたんですね。当時の名前を「CXライブラリ」と言いいます。CXライブラリのソースコードはテープが劣化して失われてしまったんですけれども、今でも、たとえばRubyのメソッドキャッシュの部分はここから流用されていたんです。そういう期待の企画ではあったんですが、ちょっと尖りすぎていて一般の人にはウケないから売れないだろうという判断でボツになりました。

しかし、企画はボツになっても、動き始めたものは止まらないので作り続けたわけですね。作り続けたものが、名前を決めるという話になって、Rubyという名前になって、そのまま作り続けて今に至ったわけです。残りの30年については今日他の人から話があったのであまり触れませんが、なぜ作り続けたのかっていうと、それは、私の「夢」だったんですね。何かというと、自分の言語を作りたい。普通言語というのは、既存のものがあって、それを「ああ、こんな言語だな」と学ぶわけですよね。そうではなくて、自分が文法を決めて、自分が実装して、自分のコントロールできる言語が欲しいと思っていたんですね。実はRubyの前に、作りかけの「Tish」という名前の言語がありました。1992年ごろに、オブジェクト指向シェルっぽいものを作りたいと思って、それがRubyの原点になりました。「Tish」というのは本邦初公開です。シェルというのはスクリプト言語をイメージしていたので、だいぶRubyに近い感じです。且つ、オブジェクト指向機能をもっている。先ほど言ったCXライブラリとともにRubyの基礎になったんですけれども、名前重要というのがよくわかりますね。もしそのまま「Tish」という名前で公開したとしたらみんなTish使いたくないですよね。Rubyだから使いたいんですよね。名前重要だというのが本当によくわかります。

### 言語を作るという「夢」

その前の1989年頃、私は大学生だったんですけれども、卒業論文で「Classic」というプログラミング言語を作りました。これも、恥ずかしいのでたくさんは公開してなんですが。大体研究室というのは研究室のテーマがあってそれを分割して卒論を書くという感じだったんですけれども、私は当時から夢でどうしても自分のプログラミング言語を作りたかったので、先生の言うことをあまり聞かずに、自分の言語をデザインして作って卒業論文を書いて提出したんですね。そうすると卒論発表会の時に、自分の担当の研究室の先生が手を挙げて「これは一体どういうことかね」と質問されてだいぶ厳しい思いをしました。

当時読んでいた本で『Object Oriented Software Construction』があります。Eiffelというプログラミング言語を作ったBertrand Meyerさんが書いた本だったのですけれども、1998年くらいにこの本を買ってものすごく感銘を受けました。Adaというアルゴル系のプログラミング言語にオブジェクト指向的拡張を加えて色々な不要なものを落として作られたのがEiffelという言語でした。Bertrand Meyerさんはフランス人なので、エッフェル塔を作ったギュスタフ・エッフェルさんを尊敬して、その名前をつけました。これと同じベクトルの変化をCに対して加えると、C++ではないオブジェクト指向Cを作れるのではないかというのが私の卒論の原理だったんですね。Eiffel的観点を入れたので、静的型で多重継承があって、プロファイル型があるような言語をデザインしました。プロファイル型というのは同じクラスの一部の使用を見ることができるというGoで言うとinterface{}型にあたるようなものです。

とりあえず動くところまで持っていって卒業論文を書いたのですが、結果的にはRubyにとって反面教師になりました。結論としてRubyには静的型がありませんでしたし、多重継承も入りませんでしたし、静的型もないのでプロファイル型もなかったということになります。結局作ってわかったのは、AdaやEiffelのアプローチよりもLispやSmalltalkのような柔軟な、フレキシビリティの高いものの方が自分に合っていると思ったんですね。ただ、何らかの形で多重継承は必要だろうと思ってMixinをRubyに導入しました。動的型や型推論のアイディアもありましたが、Classicもテープの劣化により失われました。ソースコードはどこにもありません。ただ、紙に印刷した卒論は残っています。

さらに遡って1982年頃、高校生だったんですけれども、その頃に作っていたのが「Alpha」です。これも本邦初公開です。Alphaは「ぼくのかんがえたさいきょうのげんご」という感じだったんですけれども、当時使っていたコンピュータはPC-8801（無印）で、同時に使っていたコンピュータがSHARPのPC-1210というポケットコンピュータでした。どちらも電源を入れるとBASICが動くんですよね。言語を作るとかいう感じではないんですよ。当時、尖ったプログラマーたちはアセンブラを駆使してPC-8080とかで言語を作るみたいな人もいましたけれど、私はそんなとんがったプログラーではないので、当時のプログラミング環境や当時の私のスキルではプログラミング言語を作りたいと思っても作ることが全然できなかったんですね。

本屋に行ってプログラミング言語を作る方法はないか調べてみても、『コンパイラ』という本が売っていて開けてみると訳がわからないんですね。中田先生というのちに私の大学の先生になった人が書いた本を読んだんですけれども、大学の教科書はわからないんですよね。もう1つ『やさしいコンパイラの作り方』という本もあって、ちょっと薄いし「これならわかるかな」と思ったら、”やさしい”というのがコンパイラの方にかかるんですよ。つまり、仕様が小さいコンパイラ、という。作り方は決してやさしくない。

当時インターネットもなくて、しょうがないので、「ちゃんとしたコンピュータが手に入って、ちゃんとしたスキルが身について、ちゃんとプログラミングができるようになったら、こんなプログラミング言語を作りたい」という妄想をするわけですよね。大体私は小学生の頃から妄想タイプだったので、「いつか自分の言語ができたらな、へへへ」とか言いながらノートに自分の妄想した言語でプログラムを書いていました。このAlphaについては仕様とか何も覚えていなくて、作ったことしか覚えていませんが、ノートの紛失によって失われてしまいました。

さらに遡って1980年頃。サミュエル・R・ディレーニイという人が書いた『バベル17』という小説があります。バベル17というのは一種の暗号なんですけれど、その暗号というのは実は人工的な言語であったと、サピア・ウォーフ仮説を反映したような小説で、ぜひ読んでいただきたいです。この時には、人工の言語というものにはまったんですね。たとえばエスペラントであるとか。その後にプログラミング言語っていうものにはまったんですね。というふうに、言語を作ることそのものが私にとって「夢」だったんですね。自分で決めたんですよ。

さっきも言いましたが、プログラミング言語ってふつうの人にとっては学ぶものなんですよね。どこかにあって、それをダウンロードしてあるいは買ってきて、プログラムを書いて実行する。私にとってはプログラミング言語というのは作りたいものなんですね。

40年前の鳥取・島根を思い出していただけるとイメージできる方ももしかしたらいらっしゃるかもしれませんが、高校生くらいまで、コンピュータとか一般的じゃなかったんですね。秋葉原みたいなところがあるわけでもないし。そうすると、周りにプログラミングする人がいないわけですよ。情報というのは、たとえば「アスキー」とか「アイオー」とか「マイコン」とか「ラム」みたいなマイコン雑誌と言われてる雑誌くらいしかなくて、その雑誌には「プログラミング言語新しいのができました」とか「こんな新しいプログラミング言語」みたいな記事が載るわけですね。プログラミング言語に興味ある人のうちの、10人に一人〜3人に一人くらいはプログラミング言語を作りたいと思うんじゃないだろうかと思っていました。大学に行って周りにコンピュータサイエンスを勉強したい人が増えて、プログラミングに詳しい人が増えると、プログラミング言語を作りたい人は本当に少数派だと気づいたんですけれど、手遅れだったんですね。

こうして、作りたいと思ってから10年以上経ってからスキルと環境が追いついて作ることができるようになりました。Rubyというのは今から数えて40年以上前から私の持っていた夢が実現したものであると言えます。"One man’s dream"というディズニーの曲がありますが、一人の男が「作りたい！」と思ったものが現実化して、高橋さんが言ったようないろんな段階を踏んで世界に広まり、世界を変えたということが言える。昨日あたりから #ruby30th をみると、本当にたくさんの人たちがRubyを使って生活が変わったとか、就職できて結婚できてとか怪しい通販の広告みたいな感じがしましたけれど（笑）、それも含めて本当にたくさんの人たちの人生に影響を与えたと思います。自分のうちの犬の名前をRubyにした人もいましたし、自分の子どもの名前をRubyにした人もいましたね。タイトルの「D is for Dream」というのは、Rubyは私の夢の実現であるというのをご紹介しようと思って持ってきました。

### Rubyの未来

ここからはRubyの未来の話をします。Rubyのソースコードのうち、私が書いたものがどれくらい残っているかカウントしました。2年くらい前にカウントした時点では1割くらいでした。それからYJITとかも増えたりしているので、多分今は1割以下、5〜7％くらいあったらいい方という感じです。つまり、今Rubyのソースコードをダウンロードすると何十万行もあるんですけれど、私がRubyを作ったと言いつつも、その中で実際に私が作ったRubyのコードというのはもう1割を切っているんですね。どちらかというと、「私の作ったRuby」みたいな感じじゃないんですね。今日Yuguiさんが、1.8の頃は問題があったと言っていましたが、あの頃は大体私のコードだったので、問題があったのは私のコードで、問題が解決したのはみなさんのコードなんですね。外見は同じでも中身は細心になっている。そういう意味で言うと宇宙戦艦ヤマトとか銀河鉄道999みたいですね。外見は古めかしい軍艦であるとか、外見は古めかしいSL機関車であるけど、中身は最新であるっていう感じで、松本零士のような感じの構造を持っているんじゃないかなあという気がします。

この傾向はこれからも継続するつもりです。つまり、次々起きてくる問題、現代ならではの問題を解決するんだけども、外観はさほど変わらないと。0.49から今でも動くQuineが書けるっていう。よく書けましたね、あれ。これからのRubyというのは、言語仕様は大体同じなんだけれども、、文法を少しずつ拡張するかもしれないし、ライブラリも拡張するかもしれないし、既存のライブラリにメソッドが少しずつ増えるとか、そういうことはあるかもしれないし、Rubyを取り巻く文化というのだんだん変化していくかもしれないと思っています。Rubyを取り巻く、あるいはRailsを取り巻く文化さえもどんどん変化していくので、それに伴ってRubyのコミュニティが生成していくコードも変化していくというふうに思います。個別のライブラリやフレームワークもどんどん進化していくだろうと思います。

さらに、Ruby3.0以降、ツールの充実というのを強く強く訴えてきました。それに応えてTypeProfであるとかRBSであるとか、RuboCopもそうですよね、さまざまなツールが充実してきました。あるいはLanguage Server ProtocolのRuby LSPのようなものも強化されてきて、VS Codeを使っているとTyepScriptを書いているときにいぶ追いく感じで補完されたりドキュメントがポップアップされたりするようになってきました。

先ほど奥一穂さんが発表で「Rubyは速い」と繰り返してくださって、特に私が正面に立ってメンテナンスしてた頃は「Rubyは遅い」と毎日のように言われていたので、感慨深いものがありました。Rubyの性能も随分向上しました。

これからのRubyの変化というのは、「着実な変化」というものを続けていくべきだと思ってるんですね。ただ、着実な変化だけだとおもしろくないんですよ。何かチャレンジして、「もしかしたら失敗するかもしれないけどチャレンジする。成功したら儲け物」みたいなものがコミュニティーに存在しないと、参加していて面白いコミュニティーにならないんじゃないかなと思うんですね。ちょっと前だとYJITの存在そのものが、「MJITよりもはるかに速いJITコンパイラをRubyに」と聞いて「マジかよ」って思ったんですけど、彼らShopifyのYJITチームの人たちはものすごく優秀で、すごいの持ってきてくれて「マジかー」とう感じでした。

新たなチャレンジについてお話ししようかと思います。まだ1行も書いてなく思いついただけですが、それで「V for Vaporware」と。Vaporwareとは”存在しないもの”という意味ですが、作りたいものはStatic Compiler For Rubyで、最近AOT (Ahead-of-time)コンパイルと言って、Rubyのプログラムをのマシン語に直接変換するという。昔笹田くんが東大にいた頃の学生さんんとかいろいろチャレンジした人もいるんですけれども、正直いうとあんまり性能が出なかったんですよね。しかし現代においては、使える戦略みたいなものが当時に比べだいぶん増えてきました。Abstract Interpretationであるとか、Profile Guided Type Interfaceであるとか、Interactive Annotationであるとか、Descriptive Typeであるとか。そういうアイディアを使うともうちょっとましなものが作れるんじゃないかなと思っています。

Abstract Interpretationというのは抽象解釈なんですけれども、実行をトレースして型情報を収集するタイプのアルゴリズムです。今遠藤さんがすごく頑張って作ってくださっているTypeProfの基礎になっているアルゴリズムですけれども、ソースコードから型情報を収集してきて、RBSに似た感じで表現される一種の型データーベースを用意すると。

それから、Go1.20にProfile Guided Optimizationというのが入りました。実行時にどんな型で呼ばれたかとか、どういうレシーバに対して呼ばれたかっていうのを保存しておいて、その情報を次回のコンパイルに利用しようというアイディアです。それを最適化だけではなく型推定にも使うために実行時型情報を保存すると。そうすると、抽象解釈で失われがちな型情報を集めることができる、というのがProfile Guided Type Interfaceです。これは結局JITがやっているのと同じアプローチなんですね。JITというのは実行時の情報を集めてきてそれに合わせてコンパイルするわけなので。そうすると、無駄な型チェックをガードとかで外すことができるので、より高速にコンパイルすることができる余地があると。これも型データベースに保存しておくと型情報が取れるものです。

Interactive Annotationというのは、どちらかというといいアイディアとは思っていないのですが、実行時情報とか抽象解釈だけでは補いきれない情報が存在するので、本当にわからなかったらコンパイラが諦めて聞きにくるんですね。「この行のこの型はこれだと思うんですがあっていますか」とか。ポップアップで聞いてくるという感じです。今までのコンパイルとは全く違うアプローチになるわけですけれども、欠点としては、ソース以外の情報になるので、結局ソースを見ただけではわからない情報をどこかに書いてどこかにしまわれているというのであんまりいいアプローチと思っていません。どうしてもわからない時だけ使う最後の手段じゃないかなと思っています。

Descriptive Typeというのは、普通型情報というのは"String型"とか"Integer型"とか、あるいはGenericとして"Integerの配列"みたいなのを考えるのですけれども、型情報ってもっと多くのものを持つことができるんじゃないかなあと思うんですね。たとえば `a=[1, 2, 3]` を呼ぶと「aは配列です。要素の型はintegerが3つ並んでいます。長さは3です。freezeされていません」というふうに、より多くの情報を持つことができると思っています。これらの情報を使って、たとえばfrozenなオブジェクトが`pop`みたいな破壊的操作をするメソッドとともに呼ばれると型エラーで弾くことができるわけですよね。あるいは、破壊的なものだと`etype`、エレメントのタイプが、3つから2つに変わるということもあり得るわけですね。より多くの情報を型にエンコーディングすることができるというふうに思っています。

{% highlight text %}
{% raw %}

a = [1, 2, 3]
a #=> type(Array, etype=[int, int, int], len=3, frozen=false)

{% endraw %}
{% endhighlight %}

そうすると、型情報が複雑且つ長くなるので、明示的型宣言のある言語には向かないんですね。つまり型というのは、持ちたい情報を全部詰め込むと型宣言に書けなくなるんですよ。書きたくなくなるんですよね。そうすると、暗黙的型の言語の方が、将来的には勝てるんじゃないかな（だといいな）と思ってるんですね。さらにいうとコンパイル型によって速度が速くなることを考えるとRubyのある種の機能を、「スピードのためだから」と言いながらサブセット化することができるんじゃないかなと思っています。たとえば、いつまでたっても導入できないfrozen string literalとか、一昨年のRubyカンファレンスで紹介したアイディアでまだ実現していないstatic barrierとかを導入することができるのではないかなと思っています。

と言っても課題は多くあります。そもそも1行も書いていないのが大きな課題です。それ以外に、型推定は大体正しいプログラムに正しい型がつくことを期待しているものですが、ソフトウェアを開発していると大体間違いがあるんですね。間違いがある時に、間違ったソースから間違った型情報を引き出して間違ったところとマッチさせると大惨事が起きる可能性があるんですよ。そういう時にどうやってエラー回復するかっていうのが私もアイディアがまだなくて、これがつまづく理由になるかなと思っています。もしかすると、ただ単にエラーメッセージが出てくるだけではなくて、対話的に間違いを教えてくれる型デバッガーのようなものが必要になるかもしれないなと思いつつ、まだ全然わかりません。今後要検討です。

Rubyのようなコンパイル型言語でCrystalがありますが、アプローチが違うんですね。Crystalは従来の静的な型で型推論できるところはしようという感じで、元々Rubyと互換だったんだけれども、Crystalのコンパイラそのものも最初Rubyで書いてあったんだけど、だんだん枝分かれしてだんだん違う言語になっているっていうのがCrystalです。型宣言を入れるつもりは全くなくて、型宣言がないままでコンパイル型言語が作れるんじゃないかなあと思っています。

相変わらず形から入るタイプなので、この言語に名前をつけました。「スピネル」と呼ぼうと思っています。スピネルって宝石なんですけれど、某漫画のキャラクターにルビー・ムーンとスピネル・サンっていう二人組が出てくるので、 Rubyと対になるからスピネルだと。コマンド名はspinにしようとか。まだ1行も書いてくなくてこれからなんですけど、随分昔から頭の片隅にこういうふうに思ってはいました。物事を０から始めると大変なのでほったらかしていたんですが、抽象解釈の実践としてのTypeProf、実行時の型情報を集めて最適化したコードを生成するYJITとか、Rubyのパーサーってメンテが大変なんですが共通パーサーとしてのYarpであるとか、そういう道具が揃ってきたので、これらの知見を流用したり参考にしたりすると、もしかするとスピネルっていうのが単なる夢物語ではないところまでいけるのではないかと考えています。ちなみに、うちの猫もスピネルです。

未来のチャレンジとして、非常に興味深いものがあるんですが、過去のRubyKaigiとかRubyカンファレンスとかのキーノートで私だいたいろんなアイディアを打ち明けるんですけれど、実現率って7割位なんですよね。3割くらいは言いっぱなしで終わる。このStatic Ruby Compilerは、3割に入るか7割に入るか私にはわからないですけれども、ただ、次の30年を考えたときにRubyという言語が生き残るために「価値」を提供し続けることだけは必要だと思うんですね。夢であるとかワクワクする気持ちとかも「価値」の中に含めて提供する必要があると思うんです。その中に「たのしいRuby」「たのしいプログラミング」っていうのも含まれていると思うんですね。Rubyがどんどん良くなっていくこと、Rubyと関わっていて新しい技術を生み出していくところを見る、自分自身も新しい技術を生み出していくのに参加していくっていうのが楽しさの一環ではないかなと思います。私たちがこのような気持ちを忘れない限り、Rubyはこの先10年20年30年生き残り続けて、そのうちもう「Rubyは死んだ」って言われなくなるんじゃないかと思っています。

Rubyの未来、ワクワクすることを待っているというか、ワクワクすることを作り出すという決意を新たにしつつ今日のキーノートを終わろうと思います。今日のキーノートは日本Rubyの会、Rubyアソシエーション、ネットワーク応用通信研究所、最近井上会長と新しい会社作ったOSS-Vision、の提供でお送りしました。どうもありがとうございました。

## クロージング

スピーカー
:　井上浩（株式会社ネットワーク応用通信研究所 会長）

昨年代表を交代して、今はネットワーク応用通信研究所を会長です。社長は前田くんと、裕蔵さんです。去年の12月までは、ネットワーク応用通信研究所の代表取締役、Rubyアソシエーションの副理事長、島根県情報産業協会としまねOSS協議会の会長を務めていました。

こちらはネットワーク応用通信研究所が作った[年表](<https://www.netlab.jp/files/nacl-pamphlet.pdf>)です。Ruby30周年に重なるところがあるので紹介させていただきます。ネットワーク応用通信研究所の事業が始まったのが1997年の3月で、この年の8月にまつもとさんも参加いただいています。今の代表の前田くんが1999年、裕蔵さんが2002年ですね。年表の下の方は高橋さんとかいろんな型が語られていいのかなと思います。色々あって、2022年の末に代表を交代したと。
![nacl-pamphlet.png]({{base}}{{site.baseurl}}/images/0062-Ruby30thReport/nacl-pamphlet-2.jpg)

こういった区切りを迎えたわけですけれども、区切りっていうのは、交代してみて思ったのですが、これまでの25年間が正しかったんじゃないのっていうことを言っていただいた気がしました。Ruby30周年の区切りは、これまでのRubyの30年は非常に正しい時代だったということを証明した区切りだったんじゃないかなと思います。改めて30周年、おめでとうございます。次の30年ですけれど、新生NaClもみなさんどうぞよろしくお願いします。

先ほどまつもとさんも紹介いただいたOSS-Visionを今年から始めようと考えています。まつもとさんが「僕は、専務取締役CTOだ」と言われるんで、「それじゃあ私は代表のCEOで」と。あと島根県庁におられた杉原さんも一緒に始めたんですが、「私はCIOがいい」ということで、3人で進めています。

OSS、コミュニティーの文化に根差したプロダクトの開発で非常にうまくいった例にRubyがあると思います。マネジメントの実効性はRubyで証明されたんじゃないかなと思います。その知見を活かしてRubyだけではなくていろんなプロダクトを応援していきたいなということを目指して、事業を進めていけたらと思っています。今年からはOSS-Visionの代表取締役、ネットワーク応用通信研究所の会長、そのほかは変わらず務めています。

サイトの紹介にも書かせていただきましたが、RubyWorld ConferenceのClosingを、2009年の第一回目から14回ずっと担当してきました。今年も11月9・10日に松江で開催されます。ぜひみなさん来ていただければと思いますし、何より15回目、記念の大会となりますので、特に毎年参加されている方はぜひお越しください。

改めてRuby30周年おめでとうございます。このイベントは一般財団法人 Rubyアソシエーション、一般社団法人 日本Rubyの会の主催で開催されています。デザインはいつもお世話になっているYunaさん、Tシャツ寄贈はOSS-Visionでした。スピーカーの皆さん、非常に熱いスピーカーの皆さんで、聞いているみなさんはお腹いっぱいになったんではないでしょうか。それに変わらないくらい熱い話をギュッと凝縮いただいた11人の皆さんもLTで発表いただきました。お疲れ様でした。

20周年・25周年を振り返ってみたいなと思います。20周年は品川の楽天タワーで開催されました。入場が大変だったということで、多くのスタッフにお手伝いいただいてスムーズに進んだと記憶しています。先ほどもご紹介した石塚圭樹さんも来ていただきました。イベントは、池澤あやかさんが盛り上げていただきまして、この2月23日がちょうど中村さんの誕生日だったということで池澤さんからケーキのプレゼント。マイクに向かって中村さんが「来てよかった!」と言ったのが今でも脳裏に鮮明に残っております。池澤さんプレゼンターでまつもとさんに花束を渡して無事終わりました。25周年は、サプライズゲストとしてまつもとさんのお嬢さんに来ていただいてプレゼンターとして花束を渡していただきました。まつもとさんはこの企画に対して、「誰がこんなことを考えたんだ」と憤慨して喜びを表しておりました。

そして今回30周年ですけれども、プレゼンターは社長に就任された方です。（ここで前田修吾さんからまつもとさんへギフトと花束の贈呈）30周年おめでとうございます。これからも皆さんで盛り上げていきたいと思います。ありがとうございました。

![贈呈.jpg]({{base}}{{site.baseurl}}/images/0062-Ruby30thReport/贈呈.jpg)

## この記事を書いた人の感想

かねこ( @neko314 )といいます。

私にとってRubyとRubyコミュニティーとの出会いは本当にライフチェンジングなもので、あの時感じた「こんなにたのしい営みがあるのか」と電気が走ったかのような衝撃がずっと忘れられません。それだけでなく、Rubyとの出会いがあったから私は他職種からプログラマーになったのですが、もし以前の仕事のままだったらコロナ禍で失業して飢えていてもおかしくなかっただろうとも思っています。これは結果的論的な話かもしれませんが、Rubyは人生を変えてくれただけでなく命まで救ってくれた存在です。

言語を作るのがMatzさんの夢だった話は以前から聞いたことはありましたが、10代の頃まで遡った話は初めてで、その分今まで以上に夢の力を強く感じました。まつもとさんやみなさんに「この夢を見て、そして実現し、継続してくださっていて、本当にありがとうございます」とこの場を借りてお礼を述べたいです。Ruby30周年おめでとうございます。これからもよろしくお願いします。
